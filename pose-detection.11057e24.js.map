{"mappings":"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","sources":["<anon>","src/scripts/pose-detection.ts"],"sourcesContent":["import \"./camera-identify-p5.2aafa147.js\";\nimport \"./camera-identify-p5.1c76dd51.js\";\n\n\nfunction $parcel$interopDefault(a) {\n  return a && a.__esModule ? a.default : a;\n}\n\n      var $parcel$global = globalThis;\n    \nvar $parcel$modules = {};\nvar $parcel$inits = {};\n\nvar parcelRequire = $parcel$global[\"parcelRequiread69\"];\n\nif (parcelRequire == null) {\n  parcelRequire = function(id) {\n    if (id in $parcel$modules) {\n      return $parcel$modules[id].exports;\n    }\n    if (id in $parcel$inits) {\n      var init = $parcel$inits[id];\n      delete $parcel$inits[id];\n      var module = {id: id, exports: {}};\n      $parcel$modules[id] = module;\n      init.call(module.exports, module, module.exports);\n      return module.exports;\n    }\n    var err = new Error(\"Cannot find module '\" + id + \"'\");\n    err.code = 'MODULE_NOT_FOUND';\n    throw err;\n  };\n\n  parcelRequire.register = function register(id, init) {\n    $parcel$inits[id] = init;\n  };\n\n  $parcel$global[\"parcelRequiread69\"] = parcelRequire;\n}\n\nvar parcelRegister = parcelRequire.register;\n\nvar $g73GA = parcelRequire(\"g73GA\");\n\nvar $klb57 = parcelRequire(\"klb57\");\nparcelRequire(\"iUyUN\");\nparcelRequire(\"5jdc5\");\n\nvar $7Pz0b = parcelRequire(\"7Pz0b\");\nlet $6d2a4222248bed99$var$isImageMode = true;\nconst $6d2a4222248bed99$var$CAPTURE_SIZE = 320;\nconst $6d2a4222248bed99$var$TARGET_SIZE = 192;\nlet $6d2a4222248bed99$var$mediaURL = '';\nlet $6d2a4222248bed99$var$movenetModel = null;\nlet $6d2a4222248bed99$var$objectDetectionModel = null;\nconst $6d2a4222248bed99$var$loaderEl = document.getElementById('loader');\nconst $6d2a4222248bed99$var$sketch = (p5)=>{\n    p5.setup = async ()=>{\n        const canvas = p5.createCanvas($6d2a4222248bed99$var$CAPTURE_SIZE, $6d2a4222248bed99$var$CAPTURE_SIZE);\n        canvas.parent('app');\n        p5.background('black');\n        p5.pixelDensity(1);\n        p5.colorMode(p5.RGB);\n        p5.noLoop();\n        init(p5);\n        await loadPoseModel();\n        await loadObjectDetectionModel();\n    };\n    p5.draw = async ()=>{\n        // if (isImageMode  && movenetModel && objectDetectionModel) {\n        //     p5.background(0);\n        // }\n        if (!$6d2a4222248bed99$var$isImageMode) p5.background(255);\n    };\n    /**--------------------------------- */ // functions\n    function init(p5) {\n        setupEventListeners(p5);\n    }\n    async function extractHumanFromImage(p5, img) {\n        return new Promise(async (resolve, reject)=>{\n            if (!$6d2a4222248bed99$var$objectDetectionModel) return reject(null);\n            // load prediction and get the bounds for the human\n            const predictions = await $6d2a4222248bed99$var$objectDetectionModel.detect(img);\n            const people = predictions.filter((item)=>item.class === 'person' && item.score > 0.7);\n            if (people.length < 1) return reject(null);\n            const person = people[0];\n            p5.loadImage($6d2a4222248bed99$var$mediaURL, (currImg)=>{\n                // once we have a human, create a rectangle bound\n                /**@todo: decide to crop & padd */ const [ax, ay, w, h] = person.bbox;\n                const max = w > h ? w : h;\n                const newX = ax + w / 2 - max / 2;\n                const newY = ay + h / 2 - max / 2;\n                const boundingImg = p5.createImage($6d2a4222248bed99$var$TARGET_SIZE, $6d2a4222248bed99$var$TARGET_SIZE);\n                boundingImg.copy(currImg, newX, newY, max, max, 0, 0, $6d2a4222248bed99$var$TARGET_SIZE, $6d2a4222248bed99$var$TARGET_SIZE);\n                p5.image(boundingImg, 0, 0);\n                return resolve(boundingImg);\n            });\n        });\n    }\n    async function detectPose(img) {\n        return new Promise(async (resolve, reject)=>{\n            if (!$6d2a4222248bed99$var$movenetModel) return reject(null);\n            await img.loadPixels();\n            const imgData = new ImageData(new Uint8ClampedArray(img.pixels), img.width, img.height, {\n                colorSpace: 'srgb'\n            });\n            const imageTensor = await $klb57.browser.fromPixels(imgData);\n            const poses = await $6d2a4222248bed99$var$movenetModel.predict($klb57.expandDims(imageTensor));\n            const points = await poses.array();\n            return resolve([\n                points,\n                img.width,\n                img.height\n            ]);\n        });\n    }\n    function drawPosePoints(points, width, height) {\n        const keyPoints = points[0][0];\n        for (const landmark of keyPoints){\n            p5.noStroke();\n            p5.fill(0, 255, 0);\n            p5.circle(landmark[1] * height, landmark[0] * width, 5);\n        }\n        p5.redraw();\n    }\n    // async function prepareUploadedImage(p5: P5, img: P5.Image) {\n    //     // manipulate the uploaded image\n    //     await img.loadPixels();\n    //     const imgData = {\n    //         data: new Uint8Array(img.pixels),\n    //         width: img.width,\n    //         height: img.height\n    //     };\n    //     const imageTensor = await tf.browser.fromPixels(imgData);\n    //     // put the alpha channel back\n    //     const tempT = tf.fill([img.height, img.width, 1], 255, 'int32');\n    //     const rgbaT = tf.concat([imageTensor, tempT], 2);\n    //     const pixelT = rgbaT.reshape([img.height * img.width * 4]);\n    //     // create an array so image can be iterated over\n    //     const arr = (await pixelT.array()) as number[];\n    //     const preview = p5.createImage(img.width, img.height);\n    //     await preview.loadPixels();\n    //     for (let i = 0; i < arr.length; i++) {\n    //         preview.pixels[i] = arr[i];\n    //     }\n    //     await preview.updatePixels();\n    //     // draw the image to fit within the canvas bounds\n    //     const [rWidth, rHeight] = img.width > img.height ? [CAPTURE_SIZE, 0] : [0, CAPTURE_SIZE];\n    //     preview.resize(rWidth, rHeight);\n    //     p5.image(preview, 0, 0);\n    // }\n    function setupEventListeners(p5) {\n        const btnCamera = document.getElementById('btn-camera');\n        const btnFileUpload = document.getElementById('file-upload');\n        const infoLabel = document.getElementById('file-info-label');\n        btnFileUpload.addEventListener('change', handleileUpload);\n        btnCamera.addEventListener('click', (e)=>{\n            e.preventDefault();\n            toggleMode(false);\n        });\n        function handleileUpload(e) {\n            const target = e.target;\n            if (!target.files || target.files.length < 1) return;\n            if ($6d2a4222248bed99$var$mediaURL) URL.revokeObjectURL($6d2a4222248bed99$var$mediaURL);\n            const file = target.files[0];\n            if (!file.type.startsWith('image/')) throw 'Only images can be uploaded!!';\n            toggleMode(true);\n            $6d2a4222248bed99$var$mediaURL = URL.createObjectURL(file);\n            infoLabel.textContent = file.name;\n            const newImg = new Image();\n            newImg.onload = async function() {\n                try {\n                    const boundImg = await extractHumanFromImage(p5, this);\n                    const [poses, width, height] = await detectPose(boundImg);\n                    drawPosePoints(poses, width, height);\n                } catch (error) {\n                    console.log('error processing...', error);\n                }\n            };\n            newImg.src = $6d2a4222248bed99$var$mediaURL;\n        }\n        function toggleMode(_mode) {\n            $6d2a4222248bed99$var$isImageMode = _mode !== undefined ? _mode : !_mode;\n            if ($6d2a4222248bed99$var$isImageMode) {\n                // in isImageMode to image\n                p5.background('white');\n                p5.noLoop();\n                return;\n            }\n            // set isImageMode to video\n            infoLabel.textContent = 'Browse files';\n            p5.loop();\n        }\n    }\n    async function loadPoseModel() {\n        try {\n            const modelURL = 'https://www.kaggle.com/models/google/movenet/tfJs/singlepose-lightning/4';\n            const localURL = 'indexeddb://models/movenet-singlepose-lightning';\n            $6d2a4222248bed99$var$loaderEl.classList.replace('hidden', 'flex');\n            console.log('loading movenet model started...');\n            const isModelLocallyAvailable = (await $klb57.io.listModels()).hasOwnProperty(localURL);\n            if (isModelLocallyAvailable) $6d2a4222248bed99$var$movenetModel = await $klb57.loadGraphModel(localURL);\n            else {\n                $6d2a4222248bed99$var$movenetModel = await $klb57.loadGraphModel(modelURL, {\n                    fromTFHub: true\n                });\n                await $6d2a4222248bed99$var$movenetModel.save(localURL);\n            }\n            console.log('loading movenet model done...');\n        } catch (error) {\n            console.log('something went wrong while loading the pose model...', error);\n        } finally{\n            $6d2a4222248bed99$var$loaderEl.classList.replace('flex', 'hidden');\n        }\n    }\n    async function loadObjectDetectionModel() {\n        console.log('loading cocossd model started');\n        try {\n            $6d2a4222248bed99$var$loaderEl.classList.replace('hidden', 'flex');\n            $6d2a4222248bed99$var$objectDetectionModel = await $g73GA.load();\n            console.log('loading cocossd model done');\n        } catch (error) {\n            console.log('something went wrong while loading object detection model ...', error);\n        } finally{\n            $6d2a4222248bed99$var$loaderEl.classList.replace('flex', 'hidden');\n        }\n    }\n};\nnew (0, (/*@__PURE__*/$parcel$interopDefault($7Pz0b)))($6d2a4222248bed99$var$sketch);\n\n\n//# sourceMappingURL=pose-detection.11057e24.js.map\n","import * as cocoSSD from '@tensorflow-models/coco-ssd';\nimport * as tf from '@tensorflow/tfjs';\nimport '@tensorflow/tfjs-backend-cpu';\nimport '@tensorflow/tfjs-backend-webgl';\nimport P5 from 'p5';\n\ntype TMode = boolean;\nlet isImageMode: TMode = true;\nconst CAPTURE_SIZE = 32 * 10;\nconst TARGET_SIZE = 192;\nlet mediaURL = '';\nlet movenetModel: tf.GraphModel<string | tf.io.IOHandler> | null = null;\nlet objectDetectionModel: cocoSSD.ObjectDetection | null = null;\n\nconst loaderEl = document.getElementById('loader') as HTMLElement;\n\nconst sketch = (p5: P5) => {\n    p5.setup = async () => {\n        const canvas = p5.createCanvas(CAPTURE_SIZE, CAPTURE_SIZE);\n        canvas.parent('app');\n        p5.background('black');\n        p5.pixelDensity(1);\n        p5.colorMode(p5.RGB);\n        p5.noLoop();\n\n        init(p5);\n        await loadPoseModel();\n        await loadObjectDetectionModel();\n    };\n\n    p5.draw = async () => {\n        // if (isImageMode  && movenetModel && objectDetectionModel) {\n        //     p5.background(0);\n        // }\n        if (!isImageMode) {\n            p5.background(255);\n        }\n    };\n\n    /**--------------------------------- */\n    // functions\n\n    function init(p5: P5) {\n        setupEventListeners(p5);\n    }\n\n    async function extractHumanFromImage(p5: P5, img: HTMLImageElement): Promise<P5.Image> {\n        return new Promise(async (resolve, reject) => {\n            if (!objectDetectionModel) return reject(null);\n\n            // load prediction and get the bounds for the human\n            const predictions = await objectDetectionModel.detect(img);\n            const people = predictions.filter((item) => item.class === 'person' && item.score > 0.7);\n            if (people.length < 1) return reject(null);\n            const person = people[0];\n\n            p5.loadImage(mediaURL, (currImg) => {\n                // once we have a human, create a rectangle bound\n\n                /**@todo: decide to crop & padd */\n                const [ax, ay, w, h] = person.bbox;\n\n                const max = w > h ? w : h;\n                const newX = ax + w / 2 - max / 2;\n                const newY = ay + h / 2 - max / 2;\n\n                const boundingImg = p5.createImage(TARGET_SIZE, TARGET_SIZE);\n                boundingImg.copy(currImg, newX, newY, max, max, 0, 0, TARGET_SIZE, TARGET_SIZE);\n                p5.image(boundingImg, 0, 0);\n                return resolve(boundingImg);\n            });\n        });\n    }\n\n    async function detectPose(img: P5.Image): Promise<[number[][][][], number, number]> {\n        return new Promise(async (resolve, reject) => {\n            if (!movenetModel) return reject(null);\n\n            await img.loadPixels();\n            const imgData = new ImageData(new Uint8ClampedArray(img.pixels), img.width, img.height, { colorSpace: 'srgb' });\n            const imageTensor = await tf.browser.fromPixels(imgData);\n\n            const poses = (await movenetModel.predict(tf.expandDims(imageTensor))) as tf.Tensor;\n            const points = (await poses.array()) as number[][][][];\n            return resolve([points, img.width, img.height]);\n        });\n    }\n\n    function drawPosePoints(points: number[][][][], width: number, height: number) {\n        const keyPoints = points[0][0];\n\n        for (const landmark of keyPoints) {\n            p5.noStroke();\n            p5.fill(0, 255, 0);\n            p5.circle(landmark[1] * height, landmark[0] * width, 5);\n        }\n        p5.redraw();\n    }\n\n    // async function prepareUploadedImage(p5: P5, img: P5.Image) {\n    //     // manipulate the uploaded image\n    //     await img.loadPixels();\n    //     const imgData = {\n    //         data: new Uint8Array(img.pixels),\n    //         width: img.width,\n    //         height: img.height\n    //     };\n    //     const imageTensor = await tf.browser.fromPixels(imgData);\n\n    //     // put the alpha channel back\n    //     const tempT = tf.fill([img.height, img.width, 1], 255, 'int32');\n    //     const rgbaT = tf.concat([imageTensor, tempT], 2);\n    //     const pixelT = rgbaT.reshape([img.height * img.width * 4]);\n    //     // create an array so image can be iterated over\n    //     const arr = (await pixelT.array()) as number[];\n    //     const preview = p5.createImage(img.width, img.height);\n    //     await preview.loadPixels();\n    //     for (let i = 0; i < arr.length; i++) {\n    //         preview.pixels[i] = arr[i];\n    //     }\n    //     await preview.updatePixels();\n    //     // draw the image to fit within the canvas bounds\n    //     const [rWidth, rHeight] = img.width > img.height ? [CAPTURE_SIZE, 0] : [0, CAPTURE_SIZE];\n    //     preview.resize(rWidth, rHeight);\n    //     p5.image(preview, 0, 0);\n    // }\n\n    function setupEventListeners(p5: P5) {\n        const btnCamera = document.getElementById('btn-camera') as HTMLButtonElement;\n        const btnFileUpload = document.getElementById('file-upload') as HTMLElement;\n        const infoLabel = document.getElementById('file-info-label') as HTMLElement;\n\n        btnFileUpload.addEventListener('change', handleileUpload);\n\n        btnCamera.addEventListener('click', (e: MouseEvent) => {\n            e.preventDefault();\n            toggleMode(false);\n        });\n\n        function handleileUpload(e: InputEvent) {\n            const target = e.target as HTMLInputElement;\n            if (!target.files || target.files.length < 1) return;\n\n            if (mediaURL) URL.revokeObjectURL(mediaURL);\n\n            const file = target.files[0];\n            if (!file.type.startsWith('image/')) {\n                throw 'Only images can be uploaded!!';\n            }\n            toggleMode(true);\n\n            mediaURL = URL.createObjectURL(file);\n            infoLabel.textContent = file.name;\n            const newImg = new Image();\n            newImg.onload = async function () {\n                try {\n                    const boundImg = await extractHumanFromImage(p5, this as HTMLImageElement);\n                    const [poses, width, height] = await detectPose(boundImg);\n                    drawPosePoints(poses, width, height);\n                } catch (error) {\n                    console.log('error processing...', error);\n                }\n            };\n            newImg.src = mediaURL;\n        }\n\n        function toggleMode(_mode: boolean | undefined) {\n            isImageMode = _mode !== undefined ? _mode : !_mode;\n            if (isImageMode) {\n                // in isImageMode to image\n                p5.background('white');\n                p5.noLoop();\n                return;\n            }\n            // set isImageMode to video\n            infoLabel.textContent = 'Browse files';\n            p5.loop();\n        }\n    }\n\n    async function loadPoseModel() {\n        try {\n            const modelURL = 'https://www.kaggle.com/models/google/movenet/tfJs/singlepose-lightning/4';\n            const localURL = 'indexeddb://models/movenet-singlepose-lightning';\n\n            loaderEl.classList.replace('hidden', 'flex');\n            console.log('loading movenet model started...');\n            const isModelLocallyAvailable = (await tf.io.listModels()).hasOwnProperty(localURL);\n\n            if (isModelLocallyAvailable) {\n                movenetModel = await tf.loadGraphModel(localURL);\n            } else {\n                movenetModel = await tf.loadGraphModel(modelURL, { fromTFHub: true });\n                await movenetModel.save(localURL);\n            }\n            console.log('loading movenet model done...');\n        } catch (error) {\n            console.log('something went wrong while loading the pose model...', error);\n        } finally {\n            loaderEl.classList.replace('flex', 'hidden');\n        }\n    }\n\n    async function loadObjectDetectionModel() {\n        console.log('loading cocossd model started');\n        try {\n            loaderEl.classList.replace('hidden', 'flex');\n            objectDetectionModel = await cocoSSD.load();\n            console.log('loading cocossd model done');\n        } catch (error) {\n            console.log('something went wrong while loading object detection model ...', error);\n        } finally {\n            loaderEl.classList.replace('flex', 'hidden');\n        }\n    }\n};\n\nnew P5(sketch);\n"],"names":["$parcel$global","globalThis","$parcel$modules","$parcel$inits","parcelRequire","id","exports","init","module","call","err","Error","code","register","$g73GA","$klb57","$7Pz0b","$6d2a4222248bed99$var$isImageMode","$6d2a4222248bed99$var$mediaURL","$6d2a4222248bed99$var$movenetModel","$6d2a4222248bed99$var$objectDetectionModel","$6d2a4222248bed99$var$loaderEl","document","getElementById","a","__esModule","default","p5","extractHumanFromImage","img","Promise","resolve","reject","people","predictions","detect","filter","item","class","score","length","person","loadImage","currImg","ax","ay","w","h","bbox","max","newX","newY","boundingImg","createImage","copy","image","detectPose","loadPixels","imgData","ImageData","Uint8ClampedArray","pixels","width","height","colorSpace","imageTensor","browser","fromPixels","poses","predict","expandDims","array","loadPoseModel","localURL","classList","replace","console","log","io","listModels","hasOwnProperty","loadGraphModel","fromTFHub","save","error","loadObjectDetectionModel","load","setup","canvas","createCanvas","parent","background","pixelDensity","colorMode","RGB","noLoop","btnCamera","btnFileUpload","infoLabel","toggleMode","_mode","undefined","textContent","loop","addEventListener","e","target","files","URL","revokeObjectURL","file","type","startsWith","createObjectURL","name","newImg","Image","onload","boundImg","landmark","points","noStroke","fill","circle","redraw","src","preventDefault","draw"],"version":3,"file":"pose-detection.11057e24.js.map"}